environment: ""
appName: app
branch: ""
version: ""
nodeSelector: {}
tolerations: {}
#  - key: "key1"
#    operator: "Equal"
#    value: "value1"
#    effect: "NoSchedule"
jaegerEnabled: false
commands: []
args: []

# replica values
# in case HPC enable
# min HPA replica
replicas: 1
buildId:
serviceAccountName: ""  # empty = use "default" service account
deployment:
  enabled: true

rbac:
  create: false
  resources: []

service:
  enabled: false
#  ports:
#    http:
#      externalPort: 8080
#      internalPort: 8080
#      protocol: TCP

serviceExternal:
  enabled: false
  # Optional annotations to be applied to service (e.g. to set AWS LB attributes)
  annotations: {}
    # service.beta.kubernetes.io/aws-load-balancer-connection-idle-timeout: "900"
serviceInternal:
  enabled: false
  # Optional annotations to be applied to service (e.g. to set AWS LB attributes)
  annotations: {}
    # service.beta.kubernetes.io/aws-load-balancer-connection-idle-timeout: "900"
  ports:
    http:
      internalPort: 80
      externalPort: 80
      protocol: TCP
  # Optional LoadBalancer IP
  loadBalancerIP: ""
  # Optional LoadBalancer Source Ranges
  loadBalancerSourceRanges: []

serviceHeadless:
  enabled: false

serviceExternalName:
  enabled: false
  externalName: ""

image:
  repository: nginx
  tag: latest

lifecycle:
#  preStop:
#    exec:
#      command: ["sleep","10"]

strategy:
  rollingUpdate:
    maxSurge:
    maxUnavailable:
  type: RollingUpdate

prometheus:
  enabled: false
  port: "8011"
  path: "/metrics"

# =============================================================================
# ServiceMonitor - Prometheus Operator Integration
# =============================================================================
# Creates ServiceMonitor CRD for automatic discovery by Prometheus Operator.
# Required: kube-prometheus-stack or Prometheus Operator installed in cluster.
# =============================================================================
serviceMonitor:
  # Enable ServiceMonitor creation
  enabled: false
  # Scrape interval (default: 30s)
  interval: 30s
  # Scrape timeout (must be less than interval)
  scrapeTimeout: 10s
  # Metrics endpoint path
  path: "/metrics"
  # Service port name to scrape (must match key in service.ports)
  port: "http"
  # Labels for Prometheus selector (e.g., release: prometheus)
  labels: {}
  # Relabeling configs (optional)
  relabelings: []
  # Metric relabeling configs (optional)
  metricRelabelings: []


resources: {}
  # requests:
  #   memory: 400Mi

ingress:
  enabled: false
  className: ""
  fqdn: ""
  aliases: ""
  vaultCert: ""
  extraHosts: {}
    # "some-host.com":
    #   locations:
    #     "/main":
    #       pathType: Exact
    #       serviceName: "test-sv"
    #       servicePort: 8888
    #     "/page":
    #       pathType: Exact
    #       serviceName: "test-sv"
    #       servicePort: 8881
    # "test.some-host.com":
    #   locations:
    #     "/secondary":
    #       pathType: Prefix
    #       serviceName: "test-sv"
    #       servicePort: 8880
    #     "/path":
    #       pathType: Prefix
    #       serviceName: "test-sv"
    #       servicePort: 8889

## =============================================================================
## Gateway API - HTTPRoute Configuration
## =============================================================================
## Gateway API is the successor to Ingress. Multiple HTTPRoutes can attach
## to the same Gateway - each service defines its own path, Gateway merges them.
## Docs: https://gateway-api.sigs.k8s.io/
##
## Simple mode:
##   gateway:
##     enabled: true
##     hostname: site.example.com
##     path: /api              # Optional, default "/"
##
## Multi-service example (each service deploys its own HTTPRoute):
##   site:    gateway.path: /        → site-sv
##   api:     gateway.path: /api     → api-sv
##   bonus:   gateway.path: /bonus   → bonus-sv
## =============================================================================
gateway:
  enabled: false

  # Hostname(s) for this service
  hostname: ""              # Single hostname
  hostnames: []             # Multiple hostnames

  # Path matching
  path: "/"                 # Path prefix for this service
  pathType: PathPrefix      # PathPrefix or Exact

  # Gateway reference (platform defaults)
  parentRef:
    name: gateway           # Gateway resource name
    namespace: ""           # Default: Release.Namespace
    sectionName: http-app   # Listener name on Gateway

  # Backend (auto-derived from service)
  backend:
    service: ""             # Default: {appName}-sv
    port: 0                 # Default: service.ports.http.externalPort

  # Annotations for HTTPRoute resource
  annotations: {}

  # Advanced: full parentRefs array (escape hatch)
  parentRefs: []

  # Advanced: full rules array (escape hatch for complex routing)
  rules: []

## =============================================================================
## In-Memory Cache (Redis) - Ephemeral cache for your service
## =============================================================================
## Creates a dedicated Redis instance for this service only.
## Perfect for session storage, API caching, rate limiting.
## Data is ephemeral - will be lost on pod restart (by design).
## =============================================================================
cache:
  enabled: false
  # Redis image
  image:
    repository: redis
    tag: "7-alpine"
  # Redis port
  port: 6379
  # Resources for Redis container
  resources:
    requests:
      memory: "64Mi"
      cpu: "50m"
    limits:
      memory: "256Mi"
      cpu: "200m"
  # Redis configuration
  maxmemory: "200mb"              # Must be less than resources.limits.memory
  maxmemoryPolicy: "allkeys-lru"  # Best for pure cache (evicts any key)
  # Additional redis.conf options (optional)
  extraConfig: ""
  # Prometheus metrics exporter sidecar
  exporter:
    enabled: true
    image:
      repository: oliver006/redis_exporter
      tag: "v1.66.0"
    port: 9121
    resources:
      requests:
        memory: "32Mi"
        cpu: "10m"
      limits:
        memory: "64Mi"
        cpu: "50m"
    # ServiceMonitor for exporter (requires Prometheus Operator)
    # Enabled by default - if you want exporter, you want metrics
    serviceMonitor:
      enabled: true
      interval: 30s
      labels: {}

job:
# If true, create simple jobs, e.g. migration
  enabled: false
  spec: {}
  # printenv:
  #   backoffLimit: 1
  #   command: ["printenv"]
  #   args: ["HOSTNAME", "PATH"]
  # host:
  #   command: ["echo"]
  #   args: ["HELLO", "WORLD"]

cloudflare:
  enabled: false

cronjob:
# If true, create cron jobs
  enabled: false
  spec: {}
  # printenv:
  #   command: ["printenv"]
  #   args: ["HOSTNAME","PATH"]
  #   schedule: "* * * * *"
  # host:
  #   command: ["echo"]
  #   args: ["HELLO", "WORLD"]
  #   schedule: "*/2 * * * *"

worker:
  # If true, create worker deployments
  enabled: false
#  spec:
#   printenv:
#    initContainers:
#      command:
#        - make
#      args:
#        - migrate-up
#        - DB_HOST=$(POSTGRES_HOST)
#        - DB_PORT=$(POSTGRES_PORT)
#        - DB_USER=$(POSTGRES_USER)
#        - DB_PASS=$(POSTGRES_PASS)
#        - DB_NAME=$(POSTGRES_DATABASE)
#     replicas: 3
#     command: ["printenv"]
#     args: ["HOSTNAME","PATH"]
#     resources:
#       limits:
#         cpu: 2000m
#         memory: 1750Mi
#       requests:
#         memory: 1750Mi
#         cpu: 200m
#     livenessProbe:
#       mode: httpGet
#       execCommand:
#         command: "cat"
#       httpGet:
#         port: 80
#         path: "/health"
#       tcpSocket:
#         port: 80
#     readinessProbe:
#       mode: httpGet
#       execCommand:
#         command: "cat"
#       httpGet:
#         port: 80
#         path: "/health"
#       tcpSocket:
#         port: 80

livenessProbe:
  enabled: false
  mode: httpGet
  execCommand:
    command: "cat"
  httpGet:
    port: 80
    path: "/health"
  tcpSocket:
    port: 80

readinessProbe:
  enabled: false
  mode: httpGet
  execCommand:
    command: "cat"
  httpGet:
    port: 80
    path: "/health"
  tcpSocket:
    port: 80

## =============================================================================
## Secrets Configuration (for developers)
## =============================================================================
## Define environment variables from Vault with explicit paths.
## Use {env} placeholder for environment substitution (dev/staging/prod).
##
## The chart automatically:
##   1. Groups secrets by Vault path
##   2. Creates VaultStaticSecret for each unique path
##   3. Filters only specified keys via transformation.includes
##   4. Mounts secrets as environment variables via envFrom
##
## Path convention: {brand}/{app-or-shared}/{env}/config
## Use {env} placeholder - it will be replaced with .Values.environment
## =============================================================================
secrets: {}
# Example:
#   # Shared secrets (one source for all services)
#   RABBITMQ_PASSWORD: "brand/shared/{env}/config"
#   RABBITMQ_USER: "brand/shared/{env}/config"
#
#   # Service-specific secrets
#   GOGO_SECRET: "brand/finance/{env}/config"
#   AUTH_TOKEN: "brand/finance/{env}/config"
#
#   # Static path (no {env} substitution)
#   MONGO_CERT: "brand/mongodb/client-cert"

## =============================================================================
## Secrets Provider Configuration (managed by DevOps/Infrastructure)
## =============================================================================
## Provider selection - determines which backend to use for secrets.
## This is typically set once per cluster/environment by infrastructure team.
## =============================================================================
secretsProvider:
  # Provider: "vault" | "aws" | "none"
  # - vault: HashiCorp Vault via Vault Secrets Operator (recommended)
  # - aws: AWS Secrets Manager / SSM via CSI Driver (legacy)
  # - none: Disabled - secrets map is ignored
  provider: "none"

  # Vault Secrets Operator settings
  # Docs: https://developer.hashicorp.com/vault/docs/deploy/kubernetes/vso
  vault:
    authRef: "vault-auth"     # VaultAuth resource name (created by infra)
    mount: "secret"           # KV secrets engine mount
    type: "kv-v2"             # Engine type: kv-v2 or kv-v1
    refreshAfter: "1h"        # How often to sync secrets

  # AWS Secrets Manager settings
  aws:
    provider: "aws"

configmap: {}
# Example (same simple interface as secrets):
#   LOG_LEVEL: "debug"
#   API_URL: "https://api.example.com"

## Legacy parameters (DEPRECATED - do not use)
vaultProjectName: ""
vaultNamespace: ""

## =============================================================================
## Image Pull Secrets Configuration
## =============================================================================
## Universal imagePullSecrets support for any container registry.
## Replaces legacy deploySecretHarbor/deploySecretNexus flags.
## =============================================================================
imagePullSecrets: []
# Example:
#   - name: gitlab-registry
#   - name: docker-hub
#   - name: ghcr-secret

## Legacy flags (DEPRECATED - use imagePullSecrets instead)
## Still supported for backward compatibility, uses hardcoded "regsecret" name
# deploySecretHarbor: false
# deploySecretNexus: false

alerting: {}
  # rules:
  #   "ContainerWaitingReason":
  #     annotations:
  #       message: '{{ $labels.container }} status - `WAITING`, reason - {{ $labels.reason }}'
  #     expr: kube_pod_container_status_waiting_reason != 0
  #     for: 1m
  #     labels:
  #       severity: critical

volume:
  enabled: false
  mount:
    readOnly: true
    path: /data
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 1Gi
  storageClass:
    name: gp2
    create: {}
#    create:
#      provisioner: "ebs.csi.aws.com"
#      parameters:
#        type: gp3
#        iops: "3000"

hpa:
  enabled: false
  maxReplicas: 6
  cpu: 70
  memory: 70

pdb:
  enabled: false
  maxUnavailable: 1

configfiles: {}
  # mountPath: "/etc/app"
  # data:
  #   config.yaml: |-
  #     foo: bar

## =============================================================================
## Shared Volumes Configuration
## =============================================================================
## Shared volumes between main container, initContainers, and extensions.
## Useful for sharing data, config files, or temporary storage between containers.
## =============================================================================
sharedVolumes: {}
# Example:
#   # EmptyDir for temporary shared storage
#   temp-data:
#     type: emptyDir
#     medium: ""              # "" (disk) or "Memory" (tmpfs)
#     mountPath: /tmp/shared
#
#   # EmptyDir with memory backing (faster, limited by RAM)
#   cache:
#     type: emptyDir
#     medium: Memory
#     mountPath: /cache
#
#   # ConfigMap volume
#   app-config:
#     type: configMap
#     name: my-configmap      # Optional: defaults to {appname}-{volumename}
#     mountPath: /etc/config
#     readOnly: true
#
#   # Secret volume
#   tls-certs:
#     type: secret
#     name: my-tls-secret     # Optional: defaults to {appname}-{volumename}
#     mountPath: /etc/ssl/certs
#     readOnly: true

extensions: {}
  # authz:
  #   image:
  #     repository: "example.org"
  #     name: "sidecar"
  #     tag: "1.0.0"
  #   command:
  #     - start
  #   args:
  #     - arg1
  #   env:
  #     foo: bar
  #   configfiles:
  #     mountPath: "/etc/sidecar"
  #     data:
  #       config.yaml: |-
  #         foo: bar
  #   lifecycle: {}
  #   livenessProbe:
  #     httpGet: {}
  #   readinessProbe:
  #     httpGet: {}
  #   resources:
  #     limits:
  #       memory: 100Mi
  #       cpu: 0.1
  #     requests:
  #       memory: 100Mi
  #       cpu: 0.1
