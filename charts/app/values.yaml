environment: ""
appName: app
branch: ""
version: ""
nodeSelector: {}
tolerations: {}
#  - key: "key1"
#    operator: "Equal"
#    value: "value1"
#    effect: "NoSchedule"
jaegerEnabled: false
commands: []
args: []

# replica values
# in case HPC enable
# min HPA replica
replicas: 1
buildId:
serviceAccountName: ""  # empty = use "default" service account
deployment:
  enabled: true

rbac:
  create: false
  resources: []

service:
  enabled: false
#  ports:
#    http:
#      externalPort: 8080
#      internalPort: 8080
#      protocol: TCP

serviceExternal:
  enabled: false
  # Optional annotations to be applied to service (e.g. to set AWS LB attributes)
  annotations: {}
    # service.beta.kubernetes.io/aws-load-balancer-connection-idle-timeout: "900"
serviceInternal:
  enabled: false
  # Optional annotations to be applied to service (e.g. to set AWS LB attributes)
  annotations: {}
    # service.beta.kubernetes.io/aws-load-balancer-connection-idle-timeout: "900"
  ports:
    http:
      internalPort: 80
      externalPort: 80
      protocol: TCP
  # Optional LoadBalancer IP
  loadBalancerIP: ""
  # Optional LoadBalancer Source Ranges
  loadBalancerSourceRanges: []

serviceHeadless:
  enabled: false

serviceExternalName:
  enabled: false
  externalName: ""

image:
  repository: nginx
  tag: latest

lifecycle:
#  preStop:
#    exec:
#      command: ["sleep","10"]

strategy:
  rollingUpdate:
    maxSurge:
    maxUnavailable:
  type: RollingUpdate

prometheus:
  enabled: false
  port: "8011"
  path: "/metrics"

resources: {}
  # requests:
  #   memory: 400Mi

ingress:
  enabled: false
  className: ""
  fqdn: ""
  aliases: ""
  vaultCert: ""
  extraHosts: {}
    # "some-host.com":
    #   locations:
    #     "/main":
    #       pathType: Exact
    #       serviceName: "test-sv"
    #       servicePort: 8888
    #     "/page":
    #       pathType: Exact
    #       serviceName: "test-sv"
    #       servicePort: 8881
    # "test.some-host.com":
    #   locations:
    #     "/secondary":
    #       pathType: Prefix
    #       serviceName: "test-sv"
    #       servicePort: 8880
    #     "/path":
    #       pathType: Prefix
    #       serviceName: "test-sv"
    #       servicePort: 8889

## =============================================================================
## HTTPRoute - Gateway API (modern alternative to Ingress)
## =============================================================================
## Gateway API is the successor to Ingress. Provides better expressiveness,
## header-based routing, traffic splitting, and cross-namespace routing.
## Requires Gateway API CRDs installed in cluster.
## Docs: https://gateway-api.sigs.k8s.io/
## =============================================================================
httpRoute:
  enabled: false
  # Annotations for the HTTPRoute resource
  annotations: {}
  # Parent Gateway references (required when enabled)
  parentRefs: []
    # - name: gateway-prod
    #   namespace: gateway-prod
    #   sectionName: https  # optional: specific listener
  # Hostnames to match (optional, matches all if empty)
  hostnames: []
    # - app.example.com
    # - www.app.example.com
  # Routing rules (optional, defaults to catch-all route to this service)
  rules: []
    # - matches:
    #     - path:
    #         type: PathPrefix  # PathPrefix, Exact
    #         value: /api
    #       headers:            # optional header matching
    #         - name: X-Version
    #           value: beta
    #       method: GET         # optional method matching
    #   backendRefs:
    #     - name: api-service-sv  # defaults to {appname}-sv
    #       port: 8080            # defaults to service.ports[0].externalPort
    #       namespace: other-ns   # optional cross-namespace
    #       weight: 100           # optional for traffic splitting
    #   filters: []               # optional filters (redirects, headers, etc)

## =============================================================================
## In-Memory Cache (Redis) - Ephemeral cache for your service
## =============================================================================
## Creates a dedicated Redis instance for this service only.
## Perfect for session storage, API caching, rate limiting.
## Data is ephemeral - will be lost on pod restart (by design).
## =============================================================================
cache:
  enabled: false
  # Redis image
  image:
    repository: redis
    tag: "7-alpine"
  # Redis port
  port: 6379
  # Resources for Redis container
  resources:
    requests:
      memory: "64Mi"
      cpu: "50m"
    limits:
      memory: "256Mi"
      cpu: "200m"
  # Redis configuration
  maxmemory: "200mb"              # Must be less than resources.limits.memory
  maxmemoryPolicy: "allkeys-lru"  # Best for pure cache (evicts any key)
  # Additional redis.conf options (optional)
  extraConfig: ""
  # Prometheus metrics exporter sidecar
  exporter:
    enabled: true
    image:
      repository: oliver006/redis_exporter
      tag: "v1.66.0"
    port: 9121
    resources:
      requests:
        memory: "32Mi"
        cpu: "10m"
      limits:
        memory: "64Mi"
        cpu: "50m"

job:
# If true, create simple jobs, e.g. migration
  enabled: false
  spec: {}
  # printenv:
  #   backoffLimit: 1
  #   command: ["printenv"]
  #   args: ["HOSTNAME", "PATH"]
  # host:
  #   command: ["echo"]
  #   args: ["HELLO", "WORLD"]

cloudflare:
  enabled: false

cronjob:
# If true, create cron jobs
  enabled: false
  spec: {}
  # printenv:
  #   command: ["printenv"]
  #   args: ["HOSTNAME","PATH"]
  #   schedule: "* * * * *"
  # host:
  #   command: ["echo"]
  #   args: ["HELLO", "WORLD"]
  #   schedule: "*/2 * * * *"

worker:
  # If true, create worker deployments
  enabled: false
#  spec:
#   printenv:
#    initContainers:
#      command:
#        - make
#      args:
#        - migrate-up
#        - DB_HOST=$(POSTGRES_HOST)
#        - DB_PORT=$(POSTGRES_PORT)
#        - DB_USER=$(POSTGRES_USER)
#        - DB_PASS=$(POSTGRES_PASS)
#        - DB_NAME=$(POSTGRES_DATABASE)
#     replicas: 3
#     command: ["printenv"]
#     args: ["HOSTNAME","PATH"]
#     resources:
#       limits:
#         cpu: 2000m
#         memory: 1750Mi
#       requests:
#         memory: 1750Mi
#         cpu: 200m
#     livenessProbe:
#       mode: httpGet
#       execCommand:
#         command: "cat"
#       httpGet:
#         port: 80
#         path: "/health"
#       tcpSocket:
#         port: 80
#     readinessProbe:
#       mode: httpGet
#       execCommand:
#         command: "cat"
#       httpGet:
#         port: 80
#         path: "/health"
#       tcpSocket:
#         port: 80

livenessProbe:
  enabled: false
  mode: httpGet
  execCommand:
    command: "cat"
  httpGet:
    port: 80
    path: "/health"
  tcpSocket:
    port: 80

readinessProbe:
  enabled: false
  mode: httpGet
  execCommand:
    command: "cat"
  httpGet:
    port: 80
    path: "/health"
  tcpSocket:
    port: 80

## =============================================================================
## Secrets Configuration (for developers)
## =============================================================================
## Simple interface to define environment variables from external secret store.
## Works like configmap - just specify ENV_VAR_NAME: "secret/path"
##
## The chart automatically:
##   1. Creates VaultStaticSecret or AWS SecretProviderClass
##   2. Syncs secrets to Kubernetes Secret
##   3. Mounts all keys as environment variables in your pods
##
## Path convention: {namespace}/{appName}/{environment}/{your-path}
## Example: if you set DB_PASSWORD: "database" in namespace "prod" with appName "myapp"
##          and environment "production", the full path will be:
##          prod/myapp/production/database
## =============================================================================
secrets: {}
# Example:
#   DB_PASSWORD: "database"      # -> {ns}/{app}/{env}/database
#   DB_USER: "database"          # Same secret, different key
#   API_KEY: "external/api"      # -> {ns}/{app}/{env}/external/api
#   SHARED_SECRET: "/absolute/path/to/secret"  # Absolute path (starts with /)

## =============================================================================
## Secrets Provider Configuration (managed by DevOps/Infrastructure)
## =============================================================================
## Provider selection - determines which backend to use for secrets.
## This is typically set once per cluster/environment by infrastructure team.
## =============================================================================
secretsProvider:
  # Provider: "vault" | "aws" | "none"
  # - vault: HashiCorp Vault via Vault Secrets Operator (recommended)
  # - aws: AWS Secrets Manager / SSM via CSI Driver (legacy)
  # - none: Disabled - secrets map is ignored
  provider: "none"

  # Vault Secrets Operator settings
  # Docs: https://developer.hashicorp.com/vault/docs/deploy/kubernetes/vso
  vault:
    authRef: "vault-auth"     # VaultAuth resource name (created by infra)
    mount: "secret"           # KV secrets engine mount
    type: "kv-v2"             # Engine type: kv-v2 or kv-v1
    refreshAfter: "1h"        # How often to sync secrets

  # AWS Secrets Manager settings
  aws:
    provider: "aws"

configmap: {}
# Example (same simple interface as secrets):
#   LOG_LEVEL: "debug"
#   API_URL: "https://api.example.com"

## Legacy parameters (DEPRECATED - do not use)
vaultProjectName: ""
vaultNamespace: ""

## =============================================================================
## Image Pull Secrets Configuration
## =============================================================================
## Universal imagePullSecrets support for any container registry.
## Replaces legacy deploySecretHarbor/deploySecretNexus flags.
## =============================================================================
imagePullSecrets: []
# Example:
#   - name: gitlab-registry
#   - name: docker-hub
#   - name: ghcr-secret

## Legacy flags (DEPRECATED - use imagePullSecrets instead)
## Still supported for backward compatibility, uses hardcoded "regsecret" name
# deploySecretHarbor: false
# deploySecretNexus: false

alerting: {}
  # rules:
  #   "ContainerWaitingReason":
  #     annotations:
  #       message: '{{ $labels.container }} status - `WAITING`, reason - {{ $labels.reason }}'
  #     expr: kube_pod_container_status_waiting_reason != 0
  #     for: 1m
  #     labels:
  #       severity: critical

volume:
  enabled: false
  mount:
    readOnly: true
    path: /data
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 1Gi
  storageClass:
    name: gp2
    create: {}
#    create:
#      provisioner: "ebs.csi.aws.com"
#      parameters:
#        type: gp3
#        iops: "3000"

hpa:
  enabled: false
  maxReplicas: 6
  cpu: 70
  memory: 70

pdb:
  enabled: false
  maxUnavailable: 1

configfiles: {}
  # mountPath: "/etc/app"
  # data:
  #   config.yaml: |-
  #     foo: bar

## =============================================================================
## Shared Volumes Configuration
## =============================================================================
## Shared volumes between main container, initContainers, and extensions.
## Useful for sharing data, config files, or temporary storage between containers.
## =============================================================================
sharedVolumes: {}
# Example:
#   # EmptyDir for temporary shared storage
#   temp-data:
#     type: emptyDir
#     medium: ""              # "" (disk) or "Memory" (tmpfs)
#     mountPath: /tmp/shared
#
#   # EmptyDir with memory backing (faster, limited by RAM)
#   cache:
#     type: emptyDir
#     medium: Memory
#     mountPath: /cache
#
#   # ConfigMap volume
#   app-config:
#     type: configMap
#     name: my-configmap      # Optional: defaults to {appname}-{volumename}
#     mountPath: /etc/config
#     readOnly: true
#
#   # Secret volume
#   tls-certs:
#     type: secret
#     name: my-tls-secret     # Optional: defaults to {appname}-{volumename}
#     mountPath: /etc/ssl/certs
#     readOnly: true

extensions: {}
  # authz:
  #   image:
  #     repository: "example.org"
  #     name: "sidecar"
  #     tag: "1.0.0"
  #   command:
  #     - start
  #   args:
  #     - arg1
  #   env:
  #     foo: bar
  #   configfiles:
  #     mountPath: "/etc/sidecar"
  #     data:
  #       config.yaml: |-
  #         foo: bar
  #   lifecycle: {}
  #   livenessProbe:
  #     httpGet: {}
  #   readinessProbe:
  #     httpGet: {}
  #   resources:
  #     limits:
  #       memory: 100Mi
  #       cpu: 0.1
  #     requests:
  #       memory: 100Mi
  #       cpu: 0.1
